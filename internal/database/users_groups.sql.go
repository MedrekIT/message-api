// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users_groups.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addMember = `-- name: AddMember :one
INSERT INTO users_groups (created_at, updated_at, user_id, of_group_id)
VALUES (
  NOW(),
  NOW(),
  $1,
  $2
)
RETURNING created_at, updated_at, user_id, of_group_id, member_type
`

type AddMemberParams struct {
	UserID    uuid.UUID
	OfGroupID uuid.UUID
}

func (q *Queries) AddMember(ctx context.Context, arg AddMemberParams) (UsersGroup, error) {
	row := q.db.QueryRowContext(ctx, addMember, arg.UserID, arg.OfGroupID)
	var i UsersGroup
	err := row.Scan(
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.OfGroupID,
		&i.MemberType,
	)
	return i, err
}

const changePermissions = `-- name: ChangePermissions :exec
UPDATE users_groups
SET member_type = $3, updated_at = NOW()
WHERE user_id = $1 AND of_group_id = $2
`

type ChangePermissionsParams struct {
	UserID     uuid.UUID
	OfGroupID  uuid.UUID
	MemberType MemberType
}

func (q *Queries) ChangePermissions(ctx context.Context, arg ChangePermissionsParams) error {
	_, err := q.db.ExecContext(ctx, changePermissions, arg.UserID, arg.OfGroupID, arg.MemberType)
	return err
}

const getBans = `-- name: GetBans :many
SELECT users_groups.created_at, users_groups.updated_at, user_id, of_group_id, member_type, id, users.created_at, users.updated_at, login, password, email, users.login AS user_login
FROM users_groups INNER JOIN users
ON users_groups.user_id = users.id
WHERE users_groups.of_group_id = $1 AND member_type = 'blocked'
`

type GetBansRow struct {
	CreatedAt   time.Time
	UpdatedAt   time.Time
	UserID      uuid.UUID
	OfGroupID   uuid.UUID
	MemberType  MemberType
	ID          uuid.UUID
	CreatedAt_2 time.Time
	UpdatedAt_2 time.Time
	Login       string
	Password    string
	Email       string
	UserLogin   string
}

func (q *Queries) GetBans(ctx context.Context, ofGroupID uuid.UUID) ([]GetBansRow, error) {
	rows, err := q.db.QueryContext(ctx, getBans, ofGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBansRow
	for rows.Next() {
		var i GetBansRow
		if err := rows.Scan(
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.OfGroupID,
			&i.MemberType,
			&i.ID,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.Login,
			&i.Password,
			&i.Email,
			&i.UserLogin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembers = `-- name: GetMembers :many
SELECT users_groups.created_at, users_groups.updated_at, user_id, of_group_id, member_type, id, users.created_at, users.updated_at, login, password, email, users.login AS user_login
FROM users_groups INNER JOIN users
ON users_groups.user_id = users.id
WHERE users_groups.of_group_id = $1 AND member_type != 'blocked'
`

type GetMembersRow struct {
	CreatedAt   time.Time
	UpdatedAt   time.Time
	UserID      uuid.UUID
	OfGroupID   uuid.UUID
	MemberType  MemberType
	ID          uuid.UUID
	CreatedAt_2 time.Time
	UpdatedAt_2 time.Time
	Login       string
	Password    string
	Email       string
	UserLogin   string
}

func (q *Queries) GetMembers(ctx context.Context, ofGroupID uuid.UUID) ([]GetMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, getMembers, ofGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMembersRow
	for rows.Next() {
		var i GetMembersRow
		if err := rows.Scan(
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.OfGroupID,
			&i.MemberType,
			&i.ID,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.Login,
			&i.Password,
			&i.Email,
			&i.UserLogin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeMember = `-- name: RemoveMember :exec
DELETE FROM users_groups
WHERE user_id = $1 AND of_group_id = $2
`

type RemoveMemberParams struct {
	UserID    uuid.UUID
	OfGroupID uuid.UUID
}

func (q *Queries) RemoveMember(ctx context.Context, arg RemoveMemberParams) error {
	_, err := q.db.ExecContext(ctx, removeMember, arg.UserID, arg.OfGroupID)
	return err
}
