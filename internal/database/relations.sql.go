// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: relations.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const acceptFriendship = `-- name: AcceptFriendship :exec
UPDATE relations
SET relationship = 'friends', updated_at = NOW()
WHERE receiver_id = $1 AND user_id = $2 AND relationship = 'pending'
`

type AcceptFriendshipParams struct {
	ReceiverID uuid.UUID
	UserID     uuid.UUID
}

func (q *Queries) AcceptFriendship(ctx context.Context, arg AcceptFriendshipParams) error {
	_, err := q.db.ExecContext(ctx, acceptFriendship, arg.ReceiverID, arg.UserID)
	return err
}

const createBlock = `-- name: CreateBlock :one
INSERT INTO relations (id, created_at, updated_at, user_id, receiver_id, relationship)
VALUES (
  $1,
  NOW(),
  NOW(),
  $2,
  $3,
  'blocked'
)
RETURNING id, created_at, updated_at, user_id, receiver_id, relationship
`

type CreateBlockParams struct {
	ID         uuid.UUID
	UserID     uuid.UUID
	ReceiverID uuid.UUID
}

func (q *Queries) CreateBlock(ctx context.Context, arg CreateBlockParams) (Relation, error) {
	row := q.db.QueryRowContext(ctx, createBlock, arg.ID, arg.UserID, arg.ReceiverID)
	var i Relation
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.ReceiverID,
		&i.Relationship,
	)
	return i, err
}

const createFriendship = `-- name: CreateFriendship :one
INSERT INTO relations (id, created_at, updated_at, user_id, receiver_id, relationship)
VALUES (
  $1,
  NOW(),
  NOW(),
  $2,
  $3,
  'pending'
)
RETURNING id, created_at, updated_at, user_id, receiver_id, relationship
`

type CreateFriendshipParams struct {
	ID         uuid.UUID
	UserID     uuid.UUID
	ReceiverID uuid.UUID
}

func (q *Queries) CreateFriendship(ctx context.Context, arg CreateFriendshipParams) (Relation, error) {
	row := q.db.QueryRowContext(ctx, createFriendship, arg.ID, arg.UserID, arg.ReceiverID)
	var i Relation
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.ReceiverID,
		&i.Relationship,
	)
	return i, err
}

const declineFriendship = `-- name: DeclineFriendship :exec
DELETE FROM relations
WHERE receiver_id = $1 AND user_id = $2 AND relationship = 'pending'
`

type DeclineFriendshipParams struct {
	ReceiverID uuid.UUID
	UserID     uuid.UUID
}

func (q *Queries) DeclineFriendship(ctx context.Context, arg DeclineFriendshipParams) error {
	_, err := q.db.ExecContext(ctx, declineFriendship, arg.ReceiverID, arg.UserID)
	return err
}

const deleteFriend = `-- name: DeleteFriend :one
DELETE FROM relations
WHERE (user_id = $1 OR receiver_id = $1)
AND (user_id = $2 OR receiver_id = $2)
AND relationship = 'friends'
RETURNING id, created_at, updated_at, user_id, receiver_id, relationship
`

type DeleteFriendParams struct {
	UserID   uuid.UUID
	UserID_2 uuid.UUID
}

func (q *Queries) DeleteFriend(ctx context.Context, arg DeleteFriendParams) (Relation, error) {
	row := q.db.QueryRowContext(ctx, deleteFriend, arg.UserID, arg.UserID_2)
	var i Relation
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.ReceiverID,
		&i.Relationship,
	)
	return i, err
}

const getBlocks = `-- name: GetBlocks :many
SELECT relations.id, relations.created_at, relations.updated_at, user_id, receiver_id, relationship, users.id, users.created_at, users.updated_at, login, password, email, users.login AS user_login
FROM relations INNER JOIN users
ON relations.receiver_id = users.id
WHERE (relations.user_id = $1) AND relations.relationship = 'blocked'
`

type GetBlocksRow struct {
	ID           uuid.UUID
	CreatedAt    time.Time
	UpdatedAt    time.Time
	UserID       uuid.UUID
	ReceiverID   uuid.UUID
	Relationship Relationship
	ID_2         uuid.UUID
	CreatedAt_2  time.Time
	UpdatedAt_2  time.Time
	Login        string
	Password     string
	Email        string
	UserLogin    string
}

func (q *Queries) GetBlocks(ctx context.Context, userID uuid.UUID) ([]GetBlocksRow, error) {
	rows, err := q.db.QueryContext(ctx, getBlocks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBlocksRow
	for rows.Next() {
		var i GetBlocksRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.ReceiverID,
			&i.Relationship,
			&i.ID_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.Login,
			&i.Password,
			&i.Email,
			&i.UserLogin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriends = `-- name: GetFriends :many
SELECT relations.id, relations.created_at, relations.updated_at, user_id, receiver_id, relationship, users.id, users.created_at, users.updated_at, login, password, email, users.login AS user_login
FROM relations INNER JOIN users
ON (relations.user_id = users.id AND relations.receiver_id = $1)
OR (relations.receiver_id = users.id AND relations.user_id = $1)
WHERE relations.relationship = 'friends'
`

type GetFriendsRow struct {
	ID           uuid.UUID
	CreatedAt    time.Time
	UpdatedAt    time.Time
	UserID       uuid.UUID
	ReceiverID   uuid.UUID
	Relationship Relationship
	ID_2         uuid.UUID
	CreatedAt_2  time.Time
	UpdatedAt_2  time.Time
	Login        string
	Password     string
	Email        string
	UserLogin    string
}

func (q *Queries) GetFriends(ctx context.Context, receiverID uuid.UUID) ([]GetFriendsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFriends, receiverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFriendsRow
	for rows.Next() {
		var i GetFriendsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.ReceiverID,
			&i.Relationship,
			&i.ID_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.Login,
			&i.Password,
			&i.Email,
			&i.UserLogin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
